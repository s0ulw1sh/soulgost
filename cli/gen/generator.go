package gen

import (
	"os"
	"strings"
	"go/ast"
)

type cliGenerator struct {
	funcs []clifuncs
}

type clifuncs struct {
	name     string
	typename string
	command  string
	ft       *ast.FuncType
	params    []cliparams
}

type cliparams struct {
	name   string
	gotype string
}

func (self *cliGenerator) checkDecls(root *ast.File) bool {
	var (
		fd *ast.FuncDecl
		se *ast.StarExpr
		id *ast.Ident
		rt *ast.Ident
		ok bool
	)

	for _, d := range root.Decls {
		if fd, ok = d.(*ast.FuncDecl); !ok || fd.Recv == nil || len(fd.Recv.List) != 1 { continue }
		if se, ok = fd.Recv.List[0].Type.(*ast.StarExpr); !ok { continue }
		if id, ok = se.X.(*ast.Ident); !ok { continue }
		if len(fd.Type.Results.List) != 1 { continue }
		if rt, ok = fd.Type.Results.List[0].Type.(*ast.Ident); !ok || rt.Name != "error" { continue }
		if !strings.HasPrefix(fd.Name.Name, "Cli") { continue }

		ok = true

		clf := clifuncs{
			name:     fd.Name.Name,
			command:  strings.ToLower(strings.TrimPrefix(fd.Name.Name, "Cli")),
			ft:       fd.Type,
			typename: id.Name,
		}

		if fd.Type.Params != nil {
			for _, l := range fd.Type.Params.List {

				if id, ok = l.Type.(*ast.Ident); !ok { continue }

				for _, n := range l.Names {
					clf.params = append(clf.params, cliparams{
						name:   n.Name,
						gotype: id.Name,
					})
				}
			}
		}

		self.funcs = append(self.funcs, clf)
	}

	return ok
}

func Generate(root *ast.File, f *os.File) bool {
	gen := cliGenerator{}

	if !gen.checkDecls(root) {
		return false
	}

	f.WriteString("package " + root.Name.Name + "\n\n")
	f.WriteString("//-soulgost\n\n")
	f.WriteString("// WARNING!!! \n")
	f.WriteString("// Code generated by \"soulgost -modes=cli\"; DO NOT EDIT!\n")
	f.WriteString("// URL - https://github.com/s0ulw1sh/soulgost\n")
	f.WriteString("// by Pavel Rid aka s0ulw1sh\n\n")
	
	// f.WriteString("import (\n")
	// f.WriteString(")\n\n")


	return true
}